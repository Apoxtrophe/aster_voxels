pub fn world_gen(
    mut commands: Commands,
    mut meshes: ResMut<Assets<Mesh>>,
    mut materials: ResMut<Assets<StandardMaterial>>,
    texture_handles: Res<TextureHandles>, 
) {
    let handle_texture = texture_handles.image_handles.get(1).expect("Texture handle not found");
    let mut combined_mesh = Mesh::new(PrimitiveTopology::TriangleList);

    //let normal = Vec3::new(0.0, 1.0, 0.0); // Normal pointing upward    
    let mut vertices = Vec::new();
    let mut indices = Vec::new();
    let mut uvs = Vec::new();
    let mut stat_index: u32 = 0;
    let mut rng = rand::thread_rng();

    
    let perlin = Perlin::new(rng.gen_range(0..=1000));

    for x in 0..WORLD_SIZE {
        for z in 0..WORLD_SIZE {
            let xi = x as f32;
            let zi = z as f32;  
            let mut index = rng.gen_range(0..=V_TEXTURE_ATLAS_SIZE + TEXTURE_BIAS);
            index = index.min(V_TEXTURE_ATLAS_SIZE);

            let texture_index = index as f32 / V_TEXTURE_ATLAS_SIZE as f32;
            let texture_size = 1.0 / V_TEXTURE_ATLAS_SIZE as f32;
            let (u_min, u_max) = ((texture_index - texture_size) as f32, texture_index as f32);
            let (v_min, v_max) = (0.0, 1.0);

            let tile_uvs = [
                Vec2::new(u_min, v_min),
                Vec2::new(u_min, v_max),
                Vec2::new(u_max, v_min),
                Vec2::new(u_max, v_max), 
            ];



            let iness: f64 = TERRIAN_ROUGHNESS;
            let terrain_height: f32 = TERRAIN_HEIGHT_VARIANCE;

            let vy1 = perlin.get([(xi as f64 - 0.5) * iness, (zi as f64 - 0.5) * iness]);
            let vy2 = perlin.get([(xi as f64 - 0.5) * iness, (zi as f64 + 0.5) * iness]);
            let vy3 = perlin.get([(xi as f64 + 0.5) * iness, (zi as f64 - 0.5) * iness]);
            let vy4 = perlin.get([(xi as f64 + 0.5) * iness, (zi as f64 + 0.5) * iness]);

            
            let tile_vertices = [
                Vec3::new(xi - 0.5, vy1 as f32 * terrain_height, zi - 0.5), // Bottom left
                Vec3::new(xi - 0.5, vy2 as f32 * terrain_height, zi + 0.5), // Top left
                Vec3::new(xi + 0.5, vy3 as f32 * terrain_height, zi - 0.5), // Bottom right
                Vec3::new(xi + 0.5, vy4 as f32 * terrain_height, zi + 0.5), // Top right
            ];

            let offset = stat_index * 4;
            let tile_indices = [
                0 + offset, 1 + offset, 3 + offset,
                0 + offset, 3 + offset, 2 + offset,
            ];

            vertices.extend_from_slice(&tile_vertices);
            uvs.extend_from_slice(&tile_uvs);
            indices.extend_from_slice(&tile_indices);
            //normals.extend(vec![normal; 4]);
            stat_index += 1;
        }
    }   

    let mut normals = vec![Vec3::ZERO; vertices.len()];

    let normal_multiplier: f32 = NORMALS_MULTIPLIER;

    for i in (0..indices.len()).step_by(3) {
        let index1 = indices[i] as usize;
        let index2 = indices[i + 1] as usize;
        let index3 = indices[i + 2] as usize;
    
        let vertex1 = vertices[index1];
        let vertex2 = vertices[index2];
        let vertex3 = vertices[index3];
    
        let edge1 = (vertex2 - vertex1) * normal_multiplier;
        let edge2 = (vertex3 - vertex1) * normal_multiplier;
        let face_normal = edge1.cross(edge2).normalize();

        normals[index1] += face_normal;
        normals[index2] += face_normal;
        normals[index3] += face_normal;
    }

    for normal in normals.iter_mut() {
        *normal = normal.normalize();
    }

    combined_mesh.insert_attribute(Mesh::ATTRIBUTE_POSITION, vertices);
    combined_mesh.insert_attribute(Mesh::ATTRIBUTE_UV_0, uvs);
    combined_mesh.set_indices(Some(Indices::U32(indices)));
    combined_mesh.insert_attribute(Mesh::ATTRIBUTE_NORMAL, normals);

    let material_handle = materials.add(StandardMaterial {
        base_color_texture: Some(handle_texture.clone()),
        perceptual_roughness: GROUND_ROUGHNESS,
        metallic: GROUND_METALLIC,
        reflectance: GROUND_RELFECTANCE,
        ..Default::default()
    });

    let x_shape = Collider::from_bevy_mesh(&combined_mesh, &ComputedColliderShape::TriMesh).unwrap();

    commands.spawn(PbrBundle {
        mesh: meshes.add(combined_mesh),
        material: material_handle,
        transform: Transform::from_translation(Vec3::new(0.0, WORLD_HEIGHT, 0.0)),
        ..Default::default()
    }).insert(x_shape);
}

use std::{collections::VecDeque, time::{Duration, Instant}};

use crate::{v_components::{PositionVoxel, StateVoxel, TypeVoxel}, v_config::{BENCHMARKING, BENCHMARK_SIZE, DEBUGGING, ONE_SECOND}, v_lib::VoxelInfo, VoxelAssets};
use bevy::{asset::Assets, ecs::{entity::Entity, system::{Commands, Query, Res, ResMut, Resource}}, math::IVec3, pbr::{PbrBundle, StandardMaterial}, render::mesh::Mesh, transform::components::Transform}
;
use bevy_egui::{egui, EguiContexts};

pub fn ui_debug(
    mut contexts: EguiContexts,
    voxel_state: Res<VoxelInfo>,
    performance_metrics: &Res<PerformanceMetrics>,
) {
    egui::Window::new("Debug").show(contexts.ctx_mut(), |ui| {
        ui.label(format!("Position: {:?}", voxel_state.position));
        ui.label(format!("Voxel type: {:?}", voxel_state.voxel_type));
        ui.label(format!("Activated: {:?}", voxel_state.is_on));
        ui.label(format!("Selected voxel type: {:?}", voxel_state.selected));
        if let Some(avg_frame_time) = performance_metrics.average_frame_time() {
            let avg_frame_time_ms = avg_frame_time.as_secs_f32() * 1000.0;
            ui.label(format!("Average frame time: {:.2} ms", avg_frame_time_ms));
        } else {
            ui.label("Average frame time: Calculating...");
        }
        ui.label(format!("FPS: {:?} /s", performance_metrics.fps));
        ui.label(format!("CPU usage: {:?} %", performance_metrics.cpu_usage));
        ui.label(format!(
            "Memory usage: {:?} GB",
            performance_metrics.memory_usage / 1073741824
        ));
        ui.label(format!(
            "Voxel count: {:?}",
            performance_metrics.entity_count
        ));
    });
}

#[derive(Resource)]
pub struct OneTime;

pub fn benchmark(
    mut commands: Commands,
    voxel_assets: Res<VoxelAssets>,
    mut materials: ResMut<Assets<StandardMaterial>>,
    mut meshes: ResMut<Assets<Mesh>>,
    marker: Option<Res<OneTime>>,
) {
    if marker.is_none() && BENCHMARKING {
        let voxel_type = TypeVoxel::Xor;
        let voxel_mesh_handle = voxel_assets.create_voxel_mesh(voxel_type, &mut meshes);
        let atlas_material = voxel_assets.atlas_material(&mut materials);
        for j in 0..BENCHMARK_SIZE {
            for i in 0..BENCHMARK_SIZE {
                let position = IVec3::new(i, 1, j);

                commands
                    .spawn(PbrBundle {
                        mesh: voxel_mesh_handle.clone(),  // Use the UV mapped mesh
                        material: atlas_material.clone(), // Use the atlas material
                        transform: Transform::from_translation(position.as_vec3()),
                        ..Default::default()
                    })
                    .insert(PositionVoxel(position))
                    .insert(voxel_type)
                    .insert(StateVoxel(false));
            }
        }
        commands.insert_resource(OneTime);
    }
}

#[derive(Resource)]
pub struct PerformanceMetrics {
    frame_times: VecDeque<Duration>,
    last_update: Instant,
    pub fps: f32,
    system: sysinfo::System,
    pub cpu_usage: f32,
    pub last_cpu_update: Instant,
    pub memory_usage: u64,
    pub entity_count: usize,
}

impl PerformanceMetrics {
    pub fn new() -> Self {
        PerformanceMetrics {
            frame_times: VecDeque::new(),
            last_update: Instant::now(),
            fps: 0.0,
            system: sysinfo::System::new_all(),
            cpu_usage: 0.0,
            last_cpu_update: Instant::now(),
            memory_usage: 0,
            entity_count: 0,
        }
    }

    pub fn update(&mut self, entities: Query<Entity>) {
        let now = Instant::now();
        let frame_time = now.duration_since(self.last_update);

        self.frame_times.push_back(frame_time);

        let one_second_ago = now - ONE_SECOND;

        while self
            .frame_times
            .front()
            .map_or(false, |&t| self.last_update - t < one_second_ago)
        {
            self.frame_times.pop_front();
        }

        self.last_update = now;

        //Calculate fps
        if let Some(avg_frame_time) = self.average_frame_time() {
            self.fps = 1.0 / avg_frame_time.as_secs_f32();
        } else {
            self.fps = 0.0;
        }

        //Calculate CPU usage
        if now.duration_since(self.last_cpu_update) >= ONE_SECOND {
            self.entity_count = entities.iter().count() - 6;
            self.system.refresh_all();
            self.cpu_usage = self.system.global_cpu_info().cpu_usage() as f32;
            self.last_cpu_update = now;
            self.memory_usage = self.system.used_memory();
        }
    }

    pub fn average_frame_time(&self) -> Option<Duration> {
        let sum: Duration = self.frame_times.iter().sum();
        let count = self.frame_times.len();
        if count > 0 {
            Some(sum / count as u32)
        } else {
            None
        }
    }
}

pub fn performance_metrics_system(
    mut metrics: ResMut<PerformanceMetrics>,
    entities: Query<Entity>,
) {
    if DEBUGGING {
        metrics.update(entities);
    }
}
